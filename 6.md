<div style="width:100%; display: flex;"> <p style="margin: auto" align="center"> <a href="5.md">SeÃ§Ã£o 5</a> </p><p style="margin: auto" align="center"> <a href="0.md">Ãndice</a> </p><p style="margin: auto" align="right"> <a href="7.md">SeÃ§Ã£o 7</a> </p> </div>

---

# 6. PrincÃ­pios de Desenvolvimento de Software (com foco em SOLID)

## ğŸ” Por que princÃ­pios sÃ£o importantes?

PrincÃ­pios de desenvolvimento orientam a criaÃ§Ã£o de sistemas mais **claros**, **flexÃ­veis** e **fÃ¡ceis de manter**. Eles ajudam a evitar armadilhas comuns de design e promovem boas prÃ¡ticas que melhoram a **qualidade do cÃ³digo e da arquitetura**.

---

## ğŸ§± O que Ã© SOLID?

**SOLID** Ã© um acrÃ´nimo que representa cinco princÃ­pios fundamentais da programaÃ§Ã£o orientada a objetos, propostos por Robert C. Martin (Uncle Bob).

### 1. S â€” Single Responsibility Principle (SRP)

> Uma classe deve ter **um Ãºnico motivo para mudar**.

- Cada classe deve ter **apenas uma responsabilidade clara**.
- Facilita manutenÃ§Ã£o, testes e reutilizaÃ§Ã£o.

### 2. O â€” Open/Closed Principle (OCP)

> â€œEntidades de software devem estar **abertas para extensÃ£o**, mas **fechadas para modificaÃ§Ã£o**.â€

- Podemos adicionar novas funcionalidades **sem alterar o cÃ³digo existente**.
- Uso comum: heranÃ§a, interfaces, polimorfismo.

### 3. L â€” Liskov Substitution Principle (LSP)

> â€œObjetos de uma subclasse devem poder substituir objetos da superclasse **sem alterar o comportamento correto do programa**.â€

- Subclasses devem manter o **contrato** da superclasse.
- Garante **comportamento consistente** em hierarquias de heranÃ§a.

### 4. I â€” Interface Segregation Principle (ISP)

> â€œNenhum cliente deve ser forÃ§ado a depender de mÃ©todos que **nÃ£o utiliza**.â€

- Interfaces devem ser **especÃ­ficas e enxutas**.
- Evita que implementaÃ§Ãµes sejam forÃ§adas a lidar com mÃ©todos desnecessÃ¡rios.

### 5. D â€” Dependency Inversion Principle (DIP)

> â€œDependa de **abstraÃ§Ãµes**, nÃ£o de implementaÃ§Ãµes.â€

- MÃ³dulos de alto nÃ­vel nÃ£o devem depender de mÃ³dulos de baixo nÃ­vel.
- Ambos devem depender de **interfaces ou abstraÃ§Ãµes**.

---

## ğŸ§© Outros princÃ­pios relevantes

| PrincÃ­pio                            | Significado                                 |
| ------------------------------------ | ------------------------------------------- |
| **DRY** (Don't Repeat Yourself)      | Evite duplicaÃ§Ãµes de cÃ³digo e lÃ³gica        |
| **KISS** (Keep It Simple, Stupid)    | Prefira soluÃ§Ãµes simples e diretas          |
| **YAGNI** (You Arenâ€™t Gonna Need It) | NÃ£o implemente o que nÃ£o Ã© necessÃ¡rio agora |

---

## ğŸ’¡ Dicas prÃ¡ticas

- Use os princÃ­pios para **guiar refatoraÃ§Ãµes**.
- Ao revisar cÃ³digo, pergunte: essa classe/funÃ§Ã£o tem mais de uma responsabilidade?
- Prefira **interfaces e abstraÃ§Ãµes**, especialmente em cÃ³digo que tende a evoluir.
- Evite "classes deus" com mÃºltiplas finalidades.

---

## ğŸ“š ReferÃªncias

- Martin, R. C. (2002). _Agile Software Development: Principles, Patterns, and Practices_
- Martin, R. C. (2008). _Clean Code_
- Bob Martin's articles on [https://blog.cleancoder.com](https://blog.cleancoder.com)
- Sandi Metz â€“ _Practical Object-Oriented Design in Ruby_
